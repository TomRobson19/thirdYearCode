#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\begin_preamble
\date{}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\headheight 2cm
\headsep 2cm
\footskip 1cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip bigskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Computing Methodologies - Distributed Computing
\end_layout

\begin_layout Author
Tom Robson - hzwr87
\end_layout

\begin_layout Section
The Beta Synchroniser
\end_layout

\begin_layout Subsection
How the Beta Synchroniser works
\end_layout

\begin_layout Standard
Synchroniser Beta begins with an initialisation phase, in which a leader
 is chosen in the network and a spanning tree is constructed with this leader
 node as the root.
 For all the other nodes, in each round, when all the messages sent by a
 node have arrived at their destinations, the node determines that it is
 in the safe state.
 Once it has received safe messages from its children, it sends a safe message
 to its parent.
 These messages work up the tree, following a procedure known as a convergecast.
 When the leader receives safe messages from its children, it broadcasts
 it to all the nodes in the tree, signaling that they can now begin a new
 round.
 
\end_layout

\begin_layout Subsection
Comparison of Alpha and Beta
\end_layout

\begin_layout Standard
When performing a comparison on a graph 
\begin_inset Formula $G=(n,m)$
\end_inset

, with complexities expressed per round, it is clear that Synchroniser Alpha
 is superior in terms of time complexity
\begin_inset Formula $(O(1))$
\end_inset

 but inferior in terms of message complexity
\begin_inset Formula $(O(|m|)=O(|n^{2}|))$
\end_inset

, while synchroniser Beta is superior to Alpha in terms of message complexity
 
\begin_inset Formula $(O(|n|))$
\end_inset

 but inferior in terms of time complexity 
\begin_inset Formula $(O(|m|))$
\end_inset

.
 This difference is due to the fact that Alpha is optimised for time complexity,
 as all communication is only between neighbours, but involves a large amount
 of messages, whereas Beta is optimised for message complexity, as it sends
 only once message along each edge, but messages must be sent from the leaves
 of the spanning tree to the root, taking more time.
 
\end_layout

\begin_layout Section
The Gamma Synchroniser
\end_layout

\begin_layout Standard
The Gamma Synchroniser is essentially a combination of the Alpha and Beta
 Synchronisers that is efficient in terms both time and message complexity.
 Like Beta, it has an initialisation phase, in which the network is partitioned
 into clusters with a small diameter.
 In each of these clusters, a leader is selected and a Breadth-First Search
 Tree, or intracluster tree, is calculated with this leader as its root.
 For every pair of neighbouring clusters, one edge is chosen as the intercluster
 edge, along which all communication between the clusters will be carried
 out.
 
\end_layout

\begin_layout Standard
The Gamma Synchroniser then proceeds in two phases.
 In phase one, the Beta Synchroniser is applied to every cluster.
 As soon as each leader knows that its cluster is safe, it reports this
 fact to all of the nodes in its own cluster as well as the leaders of the
 other clusters.
 Synchroniser Alpha is then applied to the set of cluster leaders, using
 the intercluster edges, as they wait for all neighbouring cluster to confirm
 that they are safe before starting the next round.
 
\end_layout

\begin_layout Standard
When calculating the 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
time complexity of Gamma, we say the depth of each intracluster tree is
 at most k.
 In each of these trees, there are two sets of convergecast messages and
 two sets of broadcast messages.
 This has a worst-case time complexity of 4k.
 There is an additional timestep required to send messages over the intercluster
 edges, so the time complexity of Gamma is 
\begin_inset Formula $O(4k+1)$
\end_inset

, which can b simplified to 
\begin_inset Formula $O(k)$
\end_inset

.
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
When considering message complexity, we note that 4 messages are sent over
 all intracluster tree edges.
 The number of intracluster tree edges must be less that n, so the message
 complexity of this part is
\begin_inset Formula $O(4n)$
\end_inset

, or just 
\begin_inset Formula $O(|n|)$
\end_inset

.
 We must then consider the number of messages sent over the intercluster
 links, denoted here as 
\begin_inset Formula $m_{c}$
\end_inset

.
 Therefore, the overall message complexity of Gamma is 
\begin_inset Formula $O(|n+m_{c}|)$
\end_inset

.
\end_layout

\begin_layout Standard
The time and message complexities of Gamma are dependent on the number of
 clusters and their size.
 Therefore, both Alpha and Beta can be seen as special cases of Gamma, as
 if the whole graph was spanned by one cluster, it would be an instance
 Beta, and if each cluster consisted of only 1 node then it would be an
 instance of Alpha.
\end_layout

\begin_layout Section
DFSr Algorithm
\end_layout

\begin_layout Subsection
Time Complexity of DFSr
\end_layout

\begin_layout Standard
On a graph with n vertices and m edges, the time complexity of DFSr is O(m).
 This is informed by the fact that all non-root processors can only send
 a message when they have received a message, and can only send one message
 to one neighbour at a time.
 As at most two messages pass along each edge in an execution of this algorithm,
 if we assume that the maximum message delay is 1, then the worst case time
 complexity is 
\begin_inset Formula $O(2m)$
\end_inset

, simplified to 
\begin_inset Formula $O(m)$
\end_inset

.
\end_layout

\begin_layout Subsection
Applying Alpha to DFSr
\end_layout

\begin_layout Standard
When applying the Alpha Synchroniser, we introduce an message overhead of
 
\begin_inset Formula $O(m$
\end_inset

) messages per round.
 The DFSr algorithm has a message complexity of 
\begin_inset Formula $O(m)$
\end_inset

, as it sends one message per round and there are 
\begin_inset Formula $O(m)$
\end_inset

 rounds in an execution of the algorithm.
 Therefore the message complexity is 
\begin_inset Formula $O(m^{2})$
\end_inset

.
 The Alpha Synchroniser introduces an time overhead of 
\begin_inset Formula $O(1)$
\end_inset

 timesteps per round.
 Therefore the time complexity of DFSr remains 
\begin_inset Formula $O(m)$
\end_inset

.
\end_layout

\begin_layout Subsection
Applying Beta to DFSr
\end_layout

\begin_layout Standard
When applying the Beta Synchroniser, we introduce an message overhead of
 
\begin_inset Formula $O(n$
\end_inset

) messages per round, as in the tree structure the worst case is that there
 are 
\begin_inset Formula $n-1$
\end_inset

 edges, with two messages needing to travel along each.
 The DFSr algorithm has a message complexity of 
\begin_inset Formula $O(m)$
\end_inset

, as it sends one message per round and there are 
\begin_inset Formula $O(m)$
\end_inset

 rounds in an execution of the algorithm.
 Therefore the message complexity when using the Beta synchroniser is 
\begin_inset Formula $O(mn)$
\end_inset

.
 The Beta Synchroniser introduces an time overhead of 
\begin_inset Formula $O(n)$
\end_inset

 timesteps per round, as in the worst case the tree is in fact a path and
 
\begin_inset Formula $2(n-1)$
\end_inset

 timesteps are needed per round to enable Beta to function.
 Therefore the time complexity of DFSr now becomes 
\begin_inset Formula $O(mn)$
\end_inset

.
\end_layout

\begin_layout Section
The Consensus Algorithm
\end_layout

\begin_layout Standard
All 3 of the synchronisers fail to solve the consensus problem in an asynchronou
s system in the presence of crash failures.
 This is due to the fact that they require all processors to send safe messages
 before they can begin a new round.
\end_layout

\begin_layout Standard
If Alpha is applied to this algorithm, and one of the processors crashes,
 then it will not have sent safe messages to all of its neighbours.
 The neighbours require a safe message from this processor to advance to
 the next round, and if this is never sent, then they will remain stuck
 in the round that the processor crashed in.
 The neighbours of these processors will have moved onto the next round
 and sent out their information, but they will then get stuck as they do
 not receive a safe message.
 This will propagate out until the whole algorithm is stuck.
 
\end_layout

\begin_layout Standard
If Beta is used a similar problem will occur, but it will not take time
 to propagate to the whole algorithm.
 If a processor fails, then it will not send a safe message, which will
 not propagate up to the leader, which in turn will then not be able to
 commence the next round.
 
\end_layout

\begin_layout Standard
As Gamma is effectively a combination of Alpha and Beta, and neither of
 these can withstand crash failures, then it is clear that Gamma will also
 be unable to solve the consensus problem.
 
\end_layout

\begin_layout Standard
More generally, in an asynchronous system where 1 or more of the processors
 can crash there is no algorithm that solves the consensus problem, as in
 an asynchronous system we cannot tell if a processor has crashed or if
 it is just slow.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintAll"
bibfiles "distributedComputing"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
