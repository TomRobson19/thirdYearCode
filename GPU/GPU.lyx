#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage {url}
\usepackage [numbers]{natbib}
\date{}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\headheight 2cm
\headsep 2cm
\footskip 1cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip bigskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Contemporary Computer Science - GPU
\end_layout

\begin_layout Author
Tom Robson - hzwr87
\end_layout

\begin_layout Section*
Step 1
\end_layout

\begin_layout Standard
Run VTune tests and comment on them.
 Read back through slides to see what is causing the bottlenecks and choose
 a performance model.
 (Should be fine if done with slides, print out when at home)
\end_layout

\begin_layout Section*
Step 2
\end_layout

\begin_layout Standard
Split code across multiple cores (vectorise)
\end_layout

\begin_layout Standard
Split into blocks (maybe 1 for each core?) and determine which code doesn't
 ever run and store this per block.
 
\end_layout

\begin_layout Standard
Write special code without these fragments and optimise aggressively.
 ???????
\end_layout

\begin_layout Standard
Use pragmas to speed this up
\end_layout

\begin_layout Standard
Validate vectorisation has been successful (VTune)
\end_layout

\begin_layout Section*
Step 3
\end_layout

\begin_layout Standard
Parrallelise step 2 on multicore node (further instructions on coursework
 spec)
\end_layout

\begin_layout Section*
Notes from chat
\end_layout

\begin_layout Standard
Have a look at the profiling lecture/practical
\end_layout

\begin_layout Standard
He means stuff like hot functions
\end_layout

\begin_layout Standard
Step 1 - Profile it before you change anything to make sure it's getting
 better
\end_layout

\begin_layout Standard
Vectorisation is SIMD, parallelization is MIMD
\end_layout

\begin_layout Standard
You parallelize outer loops and vectorize inner loops
\end_layout

\begin_layout Standard
Don't forget to compile with -g3 --> Keeps source information in the binary,
 that way you can see line by line the expensive stuff
\end_layout

\begin_layout Standard
Can confirm the parameters matter a lot First one: size of the box Or length
 more accurately I think Second one is when to plot a file (use 0 to disable)
 Last one is density of fluid: haven't really figured out the effect of
 this one yet
\end_layout

\begin_layout Standard
Need to run for a range of parameters and get an average?
\end_layout

\begin_layout Standard
Ben do you think the model we should use should be weak scaling? --> Need
 to have a look over those lecture notes but theory yes as I can't see it
 being memory bound but could be wrong
\end_layout

\begin_layout Standard
Memory bound --> Doesn't matter if your CPU can do 1 GFLOPS if you can only
 do 0.5GFLOpS because data can't be accessed fast enough So parallelising
 the code won't help But vectorising would assuming you haven't saturated
 the memory link --> the roofline model 
\end_layout

\begin_layout Standard
It's all those graphs Tobias drew in the lectures --> The diagonal is the
 compute (performance) bound right? --> Yep --> And the horizontal is when
 the memory can't provide data fast enough --> Yep
\end_layout

\begin_layout Standard
we need to calculate what the operation:byte ratio is of the expensive code
\end_layout

\begin_layout Standard
I'm assuming a high arithmetic intensity implies compute bound --> yes
\end_layout

\begin_layout Standard
Basically if a section is slow but it doesn't do many operations per loaded
 byte It's likely memory bound
\end_layout

\begin_layout Standard
PRACTICALS HAVE STUFF ON ARITHMETIC INTENSITY CALCULATIONS
\end_layout

\begin_layout Standard
(Gustafson vs Amdahl) No but he does give you the properties of each, To
 match with the properties of our code, Amdahl's law is probably the one
 as its pretty popular
\end_layout

\end_body
\end_document
